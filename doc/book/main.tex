%% awa5x - Extended AWA5.0
%% Copyright Â© 2024 Starknights

%% This program is free software: you can redistribute it and/or modify
%% it under the terms of the GNU General Public License as published by
%% the Free Software Foundation, either version 3 of the License, or
%% (at your option) any later version.

%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.

%% You should have received a copy of the GNU General Public License
%% along with this program.  If not, see <https://www.gnu.org/licenses/>.
\documentclass[11pt,a4paper,draft]{book}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[autostyle]{csquotes}
\usepackage{verbatim}
\usepackage{parskip}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{polyglossia}
\usepackage[colorlinks,hyperindex]{hyperref}
\setdefaultlanguage{english}

\author{The Starcnight Initiatibe}
\title{The Extended AWA5 Programming Language}

\begin{document}
\frontmatter
\tableofcontents

\chapter{Preface}
(to be written.)

\mainmatter
\chapter{Introduction to Awatism}
An old adage says:
\textquote{The only way to learn a new programming language is by writing programs in it.};
thus, we'll begin our exploration of the language by presenting some
practical programs with the goal of letting you, the reader, reach the
point where you can write useful programs as quickly as possible.

To reach this goal, we will avoid getting lost in tedious details or
boring rules; rather, we will present the basics of correct programs
through working examples all the while providing only the necessary
informations to understand the given code.

On the other hand, omitting certain details and keeping the examples
simple can lead to misleading results: precaution ought to be taken
when issuing certain commands to the machine and possible techniques
to create good code might not be presented at all. The authors
encourage the reader to reach past what is shown in this chapter---or
even in this book as a whole---when starting a new project,
experiment, and find ways to improve.

\section{Greetings}
It is customary to send our regards to the world when learning a new
programming language; as such, we will now write a program which will
print these words:
\begin{verbatim}
Hello, world!
\end{verbatim}

It is assumed a basic writing environment is available to the reader,
such as being able to use a plain text editor, and that the tools
shown later are installed and available on the reader's machine.

In AWA5, the program to print \verb|Hello, world!| is:
\verbatiminput{hello1.awa}

That's an overwhelming listing of seemingly nonsensical words. For
now, let's try to get this program running: as a specific example
using the \emph{awa5x} suite of tools, create a file named
\verb|hello.awa|, then compile it as follows:
\begin{verbatim}
awa5c hello.awa > hello.wa
\end{verbatim}

If all went well, the compilation process will silently generate a
file called \verb|hello.wa|. This file is our \enquote{Hello world}
program and it can be run as follows:
\begin{verbatim}
awa5 hello.wa
\end{verbatim}

which will print:
\begin{verbatim}
Hello, world!
\end{verbatim}

Let's now examine the code. Every AWA5 program is written by composing
together two syllables: \emph{awa} and \emph{wa}; the first syllable
is to be written in isolation, following any amount of blanks, the
second one must immediately follow a syllable with no blanks
inbetween.

To better understand this rule, let's examine the second line of the
code listing:
\begin{verbatim*}
awa awawa awawa awa awawawa awawawawa
\end{verbatim*}

Each blank, indicated by the \verb*| | symbol,
separate each \emph{awa} syllable from the others;
the \emph{wa} syllable is instead connected to the
previous \emph{awa} or \emph{wa} syllable.

To be recognized as an AWA5 program, the code must begin with a single
\emph{awa} syllable. In our \enquote{Hello world} program it is the
very first line. A list of \emph{statements} follow this opening word,
each specifying an operation to be performed by the
machine. Statements are executed in order from top to bottom and the
program will terminate once the last command is reached.

Every AWA5 program operates on a hidden stack of \enquote{bubbles}
called \emph{abyss}: whenever something is \emph{pushed} inside the
abyss it will be considered the \emph{top} bubble; when programs
\emph{pop} from the abyss, this top bubble is removed. Pushing a
bubble will not make the previous one disappear; rather, it will be
stored \enquote{below} the top bubble until a pop command is
executed. The stored bubble will then become the new top.

Our \enquote{Hello world} program contains both a \emph{push} and a
\emph{pop} command, repeated multiple times in order to generate the
desired effect: the first few lines will push each letter of the
\verb|Hello, world!| sentence inside the abyss, then each value is
printed and automatically popped off.

It is important to highlighting that each character is inserted in
reversed order: the print command operates on the last inserted value,
thus to write our greetings correctly the \verb|H| letter must be
inserted last.

\textbf{Excercise 1-1}. Run the \enquote{Hello world} program. Try to
omit characters or lines and see what happens each time you compile
it. \\
\textbf{Excercise 1-2}. Change the order of each line after the first
(remember, \emph{awa} must be the very first word) and see the
result. Try adding more \emph{pop} command than \emph{push} ones and
try to answer why it doesn't work.

\section{Bits of information}
We have a working program and we know why it is written the way it is,
but we have yet to understand how it is able to understand each
statement.

As already explained, each statement is written through a series of
\emph{awa} or \emph{wa} syllables, joined to form words; each word is
categorized as part of one of two groups: it can either be a
\emph{command} or a \emph{parameter}.

Commands are the instructions given to the machine. Our \enquote{Hello
  world} example featured two commands: one to push a value inside the
abyss, one to print the top value and pop it.

Parameters are values which commands operate on. Commands can take at
most one parameter, but not all commands accept a parameter; in our
example, the command to print the top value does not have one.

To understand how to recognize a command from a parameter, let's
return to the line we examined previously:
\begin{verbatim}
awa awawa awawa awa awawawa awawawawa
\end{verbatim}

We then substitute each \emph{awa} with a 0 (zero) and each \emph{wa}
with a 1 (one):
\begin{verbatim}
0010100110111
\end{verbatim}

This substitution gives us a representation of a \emph{binary number},
that is, a number composed only of the digits zero and one. When
programming, each digit of a binary number is called \emph{bit} and
the AWA5 language recognizes commands and parameters by examining
which bits are zero and which are one.

Commands are 5-bit values, which means five digits are examined, from
left to right, to understand which command needs to be executed by the
machine. In our example, the command is \verb|00101|; converting it to
a decimal number---the system we normally use when counting---gives us
the number 5, which correspond to pushing the parameter in the abyss.

If a parameter is required by the command, eight more bits are
examined to understand the value of said parameter. In our example,
the parameter is \verb|00110111| corresponding to the number 55.

Converting each line in our \enquote{Hello world} example to
decimal numbers, we get the following:
\verbatiminput{hello2.awa}

Which number corresponds to which command, and whether or not it
accepts a parameter, is shown in more details in
Appendix~\ref{list-of-opcodes}.

\textbf{Excercise 1-3}. Try giving a parameter to the print command or
remove a parameter from a push command. You will get errors; why does
it happen? \\
\textbf{Excercise 1-4}. (This excercise is moderately advanced, if you
have little programming expertise you might want to skip it and return
back later.) Open the compiled program using an appropriate tool to
view binary files. Can you recognize the commands you wrote to print
\verb|Hello, world!|? Try to understand what the contents of the file
represent.

\appendix
\chapter{Reference Material}
\section{Introduction}
This appendix contains quick reference material, that is, lists and
tables with essential information about certain topics.

Except for important notes in specific cases, there will not be any
detailed explanation; it is recommended to first read the preceding
chapters in case something is not clear.

\section{List of commands}
\label{list-of-opcodes}
\begin{longtable}{lll}
  \toprule
  Command & Awatism & Parameter \\
  \midrule
  \textbf{NOP} & \verb|awa awa awa awa awa| & None \\
  \textbf{PRN} & \verb|awa awa awa awawa| & None \\
  \textbf{PR1} & \verb|awa awa awawa awa| & None \\
  \textbf{RED} & \verb|awa awa awawawa| & None \\
  \textbf{R3D} & \verb|awa awawa awa awa| & None \\
  \textbf{BLO} & \verb|awa awawa awawa| & Number \\
  \textbf{SBM} & \verb|awa awawawa awa| & Number \\
  \textbf{POP} & \verb|awa awawawawa| & None \\
  \textbf{DPL} & \verb|awawa awa awa awa| & None \\
  \textbf{SRN} & \verb|awawa awa awawa| & Number \\
  \textbf{MRG} & \verb|awawa awawa awa| & None \\
  \textbf{4DD} & \verb|awawa awawawa| & None \\
  \textbf{SUB} & \verb|awawawa awa awa| & None \\
  \textbf{MUL} & \verb|awawawa awawa| & None \\
  \textbf{DIV} & \verb|awawawawa awa| & None \\
  \textbf{CNT} & \verb|awawawawawa| & None \\
  \textbf{LBL} & \verb|~wa awa awa awa awa| & Number \\
  \textbf{JMP} & \verb|~wa awa awa awawa| & Numeric label \\
  \textbf{EQL} & \verb|~wa awa awawa awa| & None \\
  \textbf{LSS} & \verb|~wa awa awawawa| & None \\
  \textbf{GR8} & \verb|~wa awawa awa awa| & None \\
  \textbf{EQZ} & \verb|~wa awawa awawa| & None \\
  \textbf{TLB} & \verb|~wa awawawa awa| & AWASCII \\
  \textbf{JTL} & \verb|~wa awawawawa| & AWASCII label \\
  \textbf{CLL} & \verb|~wawa awa awa awa| & AWASCII label \\
  \textbf{RET} & \verb|~wawa awa awawa| & None \\
  \textbf{TRM} & \verb|~wawawawawa| & None \\
  \bottomrule
\end{longtable}

\begin{description}
\item[NOP] Does nothing and produces no effects.
\item[PRN] Print the top bubble as AWASCII and remove it from the abyss.
\item[PR1] Print the top bubble as a number and remove it from the abyss.
\item[RED] Request a line of AWASCII text from the user. The line will
  be stored as a double bubble comprising each character as a simple
  bubble.
\item[R3D] Request a number from the user and push it as a single
  bubble inside the abyss.
\item[BLO] Push the parameter inside the abyss.
\item[SMB] Push the top bubble down by a number of positions indicated
  by the parameter. A parameter of zero will push the bubble to the
  very bottom of the abyss.
\item[POP] Pop the top bubble off the abyss. If the bubble is double,
  each contained bubble will be pushed inside the abyss in the same
  order.
\item[DPL] Duplicate the top bubble and push it inside the
  abyss. Double bubbles will have their contents duplicated too.
\item[SRN] Create a double bubble containing the number of bubbles
  indicated by the parameter. These bubbles are moved inside the
  double bubble and not duplicated.
\item[MRG] Merge the first two bubbles into a double bubble. When at
  least one bubble is double, the contents are merged into a single
  double bubble.
\item[4DD] Sum the contents of the first two bubbles, pop them off the
  abyss and push a new bubble with the result inside the abyss. If one
  is a double bubble and the other a simple bubble, sum the value of
  the simple bubble to each item inside the double bubble; if both are
  double bubbles, sum each item until the smallest bubble runs out.
\item[SUB] Subtract the contents of the first two bubbles, pop them
  off the abyss and push a new bubble with the result inside the
  abyss. If one is a double bubble and the other a simple bubble,
  subtract the value of the simple bubble to each item inside the
  double bubble; if both are double bubbles, subtract each item until
  the smallest bubble runs out. The second bubble is subtracted from
  the top bubble.
\item[MUL] Multiply the contents of the first two bubbles, pop them
  off the abyss and push a new bubble with the result inside the
  abyss. If one is a double bubble and the other a simple bubble,
  multiply the value of the simple bubble to each item inside the
  double bubble; if both are double bubbles, multiply each item until
  the smallest bubble runs out.
\item[DIV] Divide the contents of the first two bubbles, pop them off
  the abyss and push a new bubble with the result inside the abyss. If
  one is a double bubble and the other a simple bubble, divide the
  value of the simple bubble to each item inside the double bubble; if
  both are double bubbles, divide each item until the smallest bubble
  runs out. The result is a double bubble whose first bubble is the
  quotient and the second bubble is the remainder.
\item[CNT] Push a new bubble inside the abyss with the size, in number
  of items, of the top bubble. A simple bubble has a size of zero.
\item[LBL] Register the current address at the given parameter.
\item[JMP] Move the internal instruction pointer to the address
  registered under the given parameter. Command execution will then
  resume at said address.
\item[EQL] Compare the first two bubbles: if the they have equal
  contents the next command is executed, otherwise it will be
  skipped. Single bubbles are compared directly, double bubbles will
  have each item compared.
\item[LSS] Compare the first two bubbles: if the top bubble is less
  than the bubble below the next command is executed, otherwise it
  will be skipped. Single bubbles are compared directly, double
  bubbles will have each item compared.
\item[GR8] Compare the first two bubbles: if the top bubble is greater
  than the bubble below the next command is executed, otherwise it
  will be skipped. Single bubbles are compared directly, double
  bubbles will have each item compared.
\item[EQZ] Skip the next command if the top bubble is either a double
  bubble or its value is not zero.
\item[TLB] Register the current address at the given parameter.
\item[JTL] Move the internal instruction pointer to the address
  registered under the given parameter. Command execution will then
  resume at said address.
\item[CLL] Save the current address and move the internal instruction
  pointer to the address registered under the given parameter. Command
  execution will then resume at said address. Each saved address will
  exist until the program resumes execution from one of them with the
  appropriate command.
\item[RET] Move the internal instruction pointer to the last saved
  address. Command execution will then resume at said address. The
  saved address is forgotten after execution is resumed.
\item[TRM] Terminate program execution, irrespective of any command
  that follows.
\end{description}
\end{document}
