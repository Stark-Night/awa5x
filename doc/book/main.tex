%% awa5x - Extended AWA5.0
%% Copyright Â© 2024 Starknights

%% This program is free software: you can redistribute it and/or modify
%% it under the terms of the GNU General Public License as published by
%% the Free Software Foundation, either version 3 of the License, or
%% (at your option) any later version.

%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.

%% You should have received a copy of the GNU General Public License
%% along with this program.  If not, see <https://www.gnu.org/licenses/>.
\documentclass[11pt,a4paper,draft]{book}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[autostyle]{csquotes}
\usepackage{verbatim}
\usepackage{parskip}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{mathtools}
\usepackage[math-style=ISO,warnings-off={mathtools-color,mathtools-overbracket}]{unicode-math}
\usepackage{siunitx}
\usepackage{polyglossia}
\usepackage[colorlinks,hyperindex]{hyperref}
\setdefaultlanguage{english}

\DeclareSIUnit{\degreeFahrenheit}{\textdegree{}F}

\author{The Starcnight Initiatibe}
\title{The Extended AWA5 Programming Language}

\begin{document}
\frontmatter
\tableofcontents

\chapter{Preface}
(to be written.)

\mainmatter
\chapter{Introduction to Awatism}
An old adage says:
\textquote{The only way to learn a new programming language is by writing programs in it.};
we'll begin our exploration of the language by presenting some
practical programs with the goal of letting you, the reader, reach the
point where you can write useful programs as quickly as possible.

To reach this goal, we will avoid getting lost in tedious details or
boring rules; rather, we will present the basics of correct programs
through working examples all the while providing only the necessary
informations to understand the given code.

On the other hand, omitting certain details and keeping the examples
simple can lead to misleading results: precaution ought to be taken
when issuing certain commands to the machine and possible techniques
to create good code might not be presented at all. The authors
encourage the reader to reach past what is shown in this chapter---or
even in this book as a whole---when starting a new project,
experiment, and find ways to improve.

\section{Greetings}
It is customary to send our regards to the world when learning a new
programming language; as such, we will now write a program which will
print these words:
\begin{verbatim}
Hello, world!
\end{verbatim}

It is assumed a basic writing environment is available to the reader,
such as being able to use a plain text editor, and that the tools
shown later are installed and available on the reader's machine.

In AWA5, the program to print \verb|Hello, world!| is:
\verbatiminput{hello1.awa}

That's an overwhelming listing of seemingly nonsensical words. For
now, let's try to get this program running: as a specific example
using the \emph{awa5x} suite of tools, create a file named
\verb|hello.awa|, then compile it as follows:
\begin{verbatim}
awa5c hello.awa > hello.wa
\end{verbatim}

If all went well, the compilation process will silently generate a
file called \verb|hello.wa|. This file is our \enquote{Hello world}
program and it can be run as follows:
\begin{verbatim}
awa5 hello.wa
\end{verbatim}

which will print:
\begin{verbatim}
Hello, world!
\end{verbatim}

\label{awa-bits}
Let's now examine the code. Every AWA5 program is written by composing
together two syllables:\,\emph{awa} and\,\emph{wa}; the first syllable
is to be written in isolation, following any amount of blanks, the
second one must immediately follow a syllable with no blanks
inbetween.

To better understand this rule, let's examine the second line of the
code listing:
\begin{verbatim*}
awa awawa awawa awa awawawa awawawawa
\end{verbatim*}

Each blank, indicated by the \verb*| | symbol,
separate each \emph{awa} syllable from the others;
the \emph{wa} syllable is instead connected to the
previous \emph{awa} or \emph{wa} syllable.

To be recognized as an AWA5 program, the code must begin with a single
\emph{awa} syllable. In our \enquote{Hello world} program it is the
very first line. A list of \emph{statements} follow this opening word,
each specifying an operation to be performed by the
machine. Statements are executed in order from top to bottom and the
program will terminate once the last command is reached.

Every AWA5 program operates on a hidden stack of \enquote{bubbles}
called \emph{abyss}: whenever something is \emph{pushed} inside the
abyss it will be considered the \emph{top} bubble; when programs
\emph{pop} from the abyss, this top bubble is removed. Pushing a
bubble will not make the previous one disappear; rather, it will be
stored \enquote{below} the top bubble until a pop command is
executed. The stored bubble will then become the new top.

Our \enquote{Hello world} program contains both a \emph{push} and a
\emph{pop} command, repeated multiple times in order to generate the
desired effect: the first few lines will push each letter of the
\verb|Hello, world!| sentence inside the abyss, then each value is
printed and automatically popped off.

It is important to highlighting that each character is inserted in
reversed order: the print command operates on the last inserted value,
thus to write our greetings correctly the \verb|H| letter must be
inserted last.

\textbf{Excercise 1-1}. Run the \enquote{Hello world} program. Try to
omit characters or lines and see what happens each time you compile
it. \\
\textbf{Excercise 1-2}. Change the order of each line after the first
(remember, \emph{awa} must be the very first word) and see the
result. Try adding more \emph{pop} command than \emph{push} ones and
try to answer why it doesn't work.

\section{Bits of information}
We have a working program and we know why it is written the way it is,
but we have yet to understand how it is able to understand each
statement.

Each statement is categorized as part of one of two groups: it can
either be a \emph{command} or a \emph{parameter}.

Commands are the instructions given to the machine. Our \enquote{Hello
  world} example featured two commands: one to push a value inside the
abyss, one to print the top value and pop it.

Parameters are values which commands operate on. Commands can take at
most one parameter, but not all commands accept a parameter; in our
example, the command to print the top value does not have one.

To understand how to recognize a command from a parameter, let's
return to the line we examined previously:
\begin{verbatim}
awa awawa awawa awa awawawa awawawawa
\end{verbatim}

We then substitute each \emph{awa} with a 0 (zero) and each \emph{wa}
with a 1 (one):
\begin{verbatim}
0010100110111
\end{verbatim}

This substitution gives us a representation of a \emph{binary number}:
a number composed only of the digits zero and one. Inside a program,
each digit of a binary number is called \emph{bit} and the AWA5
language recognizes commands and parameters by examining the value of
each bit.

Commands are 5-bit values, which means five digits are examined from
left to right to understand which command needs to be executed by the
machine. In our example the command is \verb|00101|; converting it to
a decimal number---the system we normally use when counting---gives us
the number \num{5}, which correspond to pushing the parameter in the
abyss.

If a parameter is required by the command, eight more bits are
examined to understand its value; in the line above the parameter is
\verb|00110111| corresponding to the number \num{55}.

Converting each line in our example to decimal numbers gives us:
\verbatiminput{hello2.awa}

Which number corresponds to which command, and whether or not it
accepts a parameter, is shown in more details in
Appendix~\ref{list-of-opcodes}.

\textbf{Excercise 1-3}. Try giving a parameter to the print command or
remove a parameter from a push command. You will get errors; why does
it happen? \\
\textbf{Excercise 1-4}. (This excercise is moderately advanced, if you
have little programming expertise you might want to skip it and return
back later.) Open the compiled program using an appropriate tool to
view binary files. Can you recognize the commands you wrote to print
\verb|Hello, world!|? Try to understand what the contents of the file
represent.

\section{Abyss Diving}
The next program converts a temperature expressed in Celsius degrees
into its Fahrenheit equivalent, using the formula \(F = \frac{9}{5}C + 32\).
We will try to convert \qty[mode=text]{100}{\degreeCelsius}, the
boiling point of water, into its Fahrenheit value:
\verbatiminput{celsius.awa}

Executing the program will tell us the result:
\qty[mode=text]{212}{\degreeFahrenheit}.

The code is not any more complicated than our \enquote{Hello world},
but introduces new commands and concepts.

Each line starting with a semicolon is a \emph{comment}, which in this
case explains what the commands below do. Anything between a semicolon
and the end of the line is ignored by the compiler, thus comments may
be used to type any kind of useful information without confusing the
machine.

The first two instructions are familiar: the program is pushing the
two values \num{100} and \num{9} inside the abyss.

\begin{verbatim}
awa awawa awawa awawawa awa awawa awa awa
awa awawa awawa awa awa awa awawa awa awawa
\end{verbatim}

On the third instruction we find the first new command:

\begin{verbatim}
awawawa awawa
\end{verbatim}

This operation removes the first two bubbles from the
abyss and multiplies them, pushing the result inside the abyss; in
this example the top bubble will be the result of \(100 \times 9\),
which is \num{900}.

The next few lines instruct the program to divide the top bubble by
\num{5}. However, the division is not applied immediately: a comment
tells us the program is going to \enquote{swap the two bubbles}.

\begin{verbatim}
awa awawa awawa awa awa awa awa awawa awawa
; swap the two bubbles
awa awawawa awa awa awa awa awa awa awa awawa
awawawawa awa
\end{verbatim}

This step is required because the top bubble is divided by the bubble
below; if \num{5} were to be the top bubble, the operation would've
been \(5 \divslash 900\) instead of \(900 \divslash 5\), which is
vastly incorrect.

The attentive reader might have noticed that the program is
calculating \[\frac{9 \times 100}{5}\] instead of following the
conversion formula.

The AWA5 language operates only on \emph{integer} values which means
numbers with decimals, like \num{1.8} or \num{3.14159}, cannot be
stored inside the abyss; the number is \emph{truncated} by removing
the fractional part---the digits after the point---instead.

In the conversion formula calculating \(\frac{9}{5}\) would normally
result in \num{1.8}, but due to truncation it will give us \[1 \times
100 + 32 = 132\] instead, which is the wrong result.

Afterwards, the program adds \num{32} to the top bubble in the
same manner as the earlier multiplication, using the appropriate
command.

The next line:
\begin{verbatim}
; pop double bubble
awa awawawawa
\end{verbatim}

is required because the division pushed inside the abyss a
\emph{double bubble}.

A single bubble pushed inside the abyss will contain the given value,
for example \num{100}, \num{9} or \num{5}; a double bubble instead
comprises other bubbles---single or double---and popping one will push
each contained bubble inside the abyss in the same order: the first
bubble will become the top bubble of the abyss.

The result pushed by the division command is a double bubble whose
first item is the quotient and the last item is the remainder.

In our example the quotient is the converted temperature; because
printing operates only on the top bubble, the double bubble is split
into its contained values to ensure the remainder does not interfere.

\textbf{Excercise 1-5}. Add a semicolon to turn the command to pop the
double bubble into a comment. Can you explain what is happening when
you execute the program? \\
\textbf{Excercise 1-6}. Take the \enquote{Hello world} program and add
a command to move the top bubble before printing. Change the parameter
and see what happens; what does a value of zero do? What if the
parameter is too big?

\section{Textual and Numerical Input}
So far our programs have worked on values we have specified directly
inside the code; however, programs often need to work on input
provided by users.

The AWA5 language recognizes two different kind of input and output:
textual and numeric. In our \enquote{Hello world} example, we have
seen textual ouput where the numbers pushed inside the abyss were
printed as letters; in the Celsius to Fahrenheit converter the output
was the quotient printed as a number.

Textual input and output operate within the bounds of the AWASCII
alphabet; any value not inside these bounds will be considered
invalid. The complete table of AWASCII characters can be found in
Appendix~\ref{list-of-awascii}.

Numeric input accepts any number that can be represented with 32 bits,
which means anything between \(-2^{31}\) and \(2^{31}-1\) or
\num{-2147483648} and \num{2147483647} in decimal notation. This
number must be written using valid AWASCII characters, thus negative
values will be prefixed with the \verb|~| symbol: \(-2\) is written as
\~{}2, for example.

\subsection{Textual input}
\label{textual-input}
Let's extend our \enquote{Hello world} program to greet anyone the
user wishes for. We will first print the \verb|~| character and wait
until the user provides valid text.
\verbatiminput{hello3.awa}

The request for input happens at the third command; once a valid line
of AWASCII character is inserted, the command pushes it inside the
abyss as a double bubble.

We proceed to insert the greeting---the word \enquote{Hello} followed
by a comma and a space, like in our first \enquote{Hello world}
program---and then we print the whole text so far.

Unlike in our first example, we do not use one command for each bubble
inside the abyss; the printing command is able to operate on double
bubbles, so we first \emph{surround} the greeting with a double bubble
and then execute only two printing commands: one to output
\verb*|Hello, |, the other to output the line provided by the user.

Finally, we push the closing exclamation mark followed by a special
character indicating the output line has ended. We surround them again
and print the two characters with a single command.

\textbf{Excercise 1-7}. Run the program and provide input lines with
characters outside the AWASCII range and see what happens. You can
find the AWASCII character table in Appendix~\ref{list-of-awascii}. \\
\textbf{Excercide 1-8}. Modify the program to print the greeting using
only one print command. The surrounding command is key.

\subsection{Numerical input}
We will extend the Celsius-to-Fahrenheit converter to operate on
numbers provided by the user. Similar to Section~\ref{textual-input},
the program will print an indicator and wait for a number.
\verbatiminput{celsius2.awa}

The code should be familiar: first we print the \verb|~| character,
then we wait for input; the sequence of commands to convert the
temperature is the same as the first version of this program.

It is important to note that numbers are inserted as AWASCII
characters; only decimal digits are allowed:
\begin{verbatim}
~100
212
\end{verbatim}
\begin{verbatim}
~0x10
<some error message.>
\end{verbatim}

This detail is important when inserting negative numbers: the \verb|-|
character, normally used to indicate a negative number such as
\num{-17}, is not part of AWASCII; to provide a negative number
the \verb|~| character is used instead:
\begin{verbatim}
~ -17
<some error message.>
\end{verbatim}
\begin{verbatim}
~ ~17
2
\end{verbatim}

\textbf{Excercise 1-9}. Can you print the result and the end of line
indicator with a single output command? This is a yes-or-no question.

\section{Repeating Actions}
Throughout our examples we have always written programs which
terminate immediately after performing all their instructions. We will
now extend the temperature converter to keep asking for new values,
allowing the user to calculate multiple conversions without restarting
the program between each input.
\verbatiminput{celsius3.awa}

The code introduces a new syllable: \verb|~wa|, indicating the bit
has a value of 1. In Section~\ref{awa-bits} we learnt that \verb|wa|,
the syllable indicating the value 1, must be attached to the previous
syllable to be valid and therefore it cannot be used at the very start
of a sequence of bits. The \verb|~wa| syllable allows a starting 1 and
as such the command \verb|~wa awa awa awa awa| is equivalent to the
\verb|10000| sequence of bits.

Let's now examine the new commands: the first,
\verb|~wa awa awa awa awa|, defines a \emph{label} identified by the
parameter, in this case the value 0. Labels are \enquote{checkpoints}
inside the code whose purpose is allowing a program to control which
commands will be executed.

The \verb|~wa awa awa awawa| command instructs the program to
\emph{jump} to the label specified by the parameter; in our case the
label 0. Once the program jumps to a label, the next command to be
executed will be the one specified after the label. In this example,
the label is defined at the very beginning of the program, resulting
in the program repeatedly converting user input.

If we try to run the program, we will soon find ourselves in a
peculiar situation: we cannot stop it without using the facilities
provided by the underlaying system. Let's modify the program to query
the user whether or not to convert another number: if an empty line is
provided, the program will end. The program will use the \verb|!|
character to notify the user about this choice.
\verbatiminput{celsius4.awa}

Users can provide empty lines in two ways: the first is by inserting a
line containing only an end-of-line marker inside, which can be
achieved for example by pressing the \enquote{Enter} button on a
keyboard; the other way is by using facilities provided by the
underlaying platform to actually send no data at all.

The AWA5 command identifies these two cases through two different
bubbles: each one is a single bubble and in the first case, an
end-of-line marker, the value of the bubble is the equivalent AWASCII
character; otherwise, it is the value \num{-1}.

In this example we do not need to check the reason why the line is
empty, thus we take the top bubble---the input given by the user---and
calculate its \emph{count}: single bubbles always have a count of
zero, while double bubbles have a count of at least 1.

The \verb|~wa awa awawa awa| command compares two bubbles to see if
they are equal. Other commands allow comparing their ordinal
properties: whether the value of the top bubble is lesser or greater
than the value of the bubble below. Double bubbles are compared by
comparing each contained bubble.

When two bubbles satisfy the requested comparison the command that
follows is executed, otherwise it is ignored. In our example, we
compare the count of the user input with the number zero: if the input
is not empty the execution jumps back to the beginning; otherwise, if
the top value is a single bubble the input is an empty line and the
\verb|~wawawawawa| command will be executed, terminating the program
immediately.

\textbf{Excercise 1-10}. Change the last example to terminate only if
the user provides the string \enquote{no}. When the input is
\enquote{yes} start a new conversion, keep asking otherwise. \\
\textbf{Excercise 1-11}. Print \enquote{hot} or \enquote{cold} after
converting the temperature, if the result is above or below \num{0}
respectively.

\section{Routines for common actions}
Sometimes it is necessary to repeat the same code in different parts
of the program.  Writing these chunks explicitly each time we need
them quickly gets out of hand, as the size of the program increases
and making a single change in the repeated code can require modifying
a large number of parts.

To simplify development it is possible to define
\emph{routines}---also called \enquote{procedures} or
\enquote{functions}---consisting in a sequence of actions associated
with a name.

A routine consist of any number of actions enclosed between two
commands: the first specifies a name for the routine and behaves in
the same fashion as the command to define a jump label; the second
command terminates the routine and we will see how it works in our
next example.

We will now create a program to count the number of characters given
as input until the end of the stream is found, which is to say a
bubble with a value of \num{-1} is pushed by the
\verb|awa awa awawawa| command. This program can be used, for example,
to know the size of a file by executing it akin to the following:
\begin{verbatim}
awa5 count-characters.wa < celsius3.awa
502
\end{verbatim}

In this case, \num{502} is the character count of the third iteration
of our temperature converter.

The code for this program is larger than our previous examples, but
that should not intimidate us:
\verbatiminput{charcount.awa}

Within the loop contained between the label \num{0} and the
\verb|~wawawawawa| command, the only awatism yet to be introduced is
\verb|~wawa awa awa awa|.

This command is part of a group of operations using \emph{textual
labels} as parameters, instead of the usual numeric ones.

Texutal labels are always included between two square brackets---the
\verb|[| and \verb|]| characters---and represent a sequence of AWASCII
characters with no limits in its length.  In this example, the first
textual label we meet is \verb|[ awa awa awa awa awa awa awa awa ]|,
equivalent to the \verb|[ A ]| sequence.

The primary role of these labels is to allow more checkpoints than the
limit of \num{255} the \verb|~wa awa awa awa awa| command has. It is
possible to rewrite every instance of numerical labels and jumps to
use textual labels and jumps, at the cost of making the code more
verbose due to AWASCII.

Unlike a normal textual jump, specified by the \verb|~wa awawawawa|
command, here we use a \emph{routine call}. Unlike normal jumps,
routines keep track of the place where the jump happened, allowing the
program to jump back there without the need of a second label.

The \verb|[ A ]| routine reads a line of input and places the size of
the bubble on top of the abyss. For simplicity, the actual input line
is moved to the bottom of the abyss.  In order to ensure the program
can quit if the line is empty, the top bubble is compared with the
value \num{-1}: if the two are not equal, the program continues as
expected; the routine stops immediately otherwise.

In both cases, execution resumes from the point after the routine call
thanks to the \verb|~wawa awa awawa| command.

\textbf{Excercise 1-12}. What happens if the \verb|~wawawawawa|
command is removed? What if the routine was placed at the beginning of
the file? You should be able to answer without executing the
program. \\
\textbf{Excercise 1-13}. Combine what you have learned so far to write
a simple calculator: ask for two numbers, then a value between \num{1}
and \num{4}; this value is associated with a routine performing a
basic arithmetic operation of your choice. Quit with the value \num{-1}.

\chapter{Commands and Types}
A program written in the extended AWA5 language is composed of three
fundamental types: commands, numerical values and textual labels.
Execution is carried on by commands; numerical values are the data
objects manipulated by commands in the form of \enquote{bubbles};
textual labels are special markers used by specific commands.

\section{Basic commands}
Most commands perform only one operation without interfering with the
normal execution of the program. These commands usually perform
changes to the abyss like adding or removing bubbles.

To add and remove bubbles, use the \textbf{BLO}, \textbf{DPL} and
\textbf{POP} commands. \textbf{SRN} and \textbf{MRG} modify existing
bubbles, altering the contents of the abyss without pushing anything
inside. The \textbf{SBM} command moves the topmost bubble to a lower
position inside the abyss; this command modifies the abyss without
adding or removing bubbles, too.

Usage of \textbf{PRN} or \textbf{PR1} results in bubbles being removed
from the abyss, with the primary side effect of displaying the
contents of those bubbles to the user, as appropriate.  \textbf{RED}
and \textbf{R3D} alter the abyss by pushing new bubbles inside,
requesting their values from the user.

\section{Arithmetic commands}
Certain commands perform basic arithmetic operations: summation,
difference, multiplication and division. Unlike basic commands, the
result of the operation can be complex or different than
expectation. These commands always take two bubbles out of the abyss
and push a new bubble inside. This bubble is the result of the
operation.

When at least one of the two bubbles is double, the operation is
recursively applied to each bubble contained within.

\textbf{4DD} and \textbf{MUL} perform as expected: the two bubbles are
added or multiplied together. The \textbf{SUB} command subtracts the
second bubble from the first; the formula \(A - B\) must therefore be
executed as the sequence:
\begin{verbatim}
BLO A
BLO B
SUB
\end{verbatim}

The result of the \textbf{DIV} command is always a double bubble in
which the first bubble is the quotient and the second is the
remainder. Applying division to double bubbles result in double
bubbles containing other double bubbles, recursively.

\section{Execution flow}
It is possible to change which command would be executed
next. Conceptually, the program has an \emph{instruction pointer}, or
IP, which is incremented by one each time a command is executed. Once
the IP reaches the end of the code section, the program terminates.

The \textbf{JMP} and \textbf{JTL} command change the IP to a different
value specified by the \textbf{LBL} and \textbf{TLB} commands. To
create a label for \textbf{JMP} use \textbf{LBL}; to create a label
for \textbf{JTL} use \textbf{TLB}.

Comparisons made using \textbf{EQL}, \textbf{LSS}, \textbf{GR8} and
\textbf{EQZ} can alter the flow by incrementing the IP by one if the
comparison holds, skipping the command that follows immediately after.

\textbf{CLL} works like \textbf{JTL}, but preserves the IP before
making the jump. The program can resume execution from the stored IP
with a jump performed by the \textbf{RET} command.

Programs can stop execution altogether with the \textbf{TRM}
command. Reaching this command terminates every activity, irrespective
of what follows.

\section{Numerical values}
Programs written in AWA5 can operate only on one type of data: integer
numbers between \num{-2147483648} and \num{2147483647}, for a total of
\num{32} bits of information.

When used as a parameter of a command a numerical value can be
represented in only eight bits, meaning the range is limited to
\num{-128} and \num{127}.

Certain commands do not accept negative values, thus their ranges are
between \num{0} and \num{4294967295} as a \num{32}-bit value, or
\num{0} and \num{255} as an \num{8}-bit value.

Numerical values can be used to define \emph{numerical labels}: the
value will be associated with a position inside the code section of
the program; using the same value as a parameter of the \textbf{JMP}
command will result in the instruction pointer moving to the
registered position, before stepping forward to the next command.

\section{Textual labels}
Certain operations do not take a numerical value as a parameter,
requiring a sequence of AWASCII character encoded as awatisms,
instead. This sequence must be enclosed withing square brackets.

A sequence abiding these rules is a \emph{textual label} and it is an
extension to numerical label to permit a program to use more than
\num{255} labels.

Textual labels can have any length as long as the characters within
are encoded as awatisms. The list of valid AWASCII can be found in
Appendix~\ref{list-of-awascii}.

Thus, the sequences \verb|[ A ]|, \verb|[ AW ]| and \verb|[ AWA ]|
would be written, respectively, as:
\begin{verbatim}
[ awa awa awa awa awa awa awa awa ]

[ awa awa awa awa awa awa awa awa
  awa awa awa awa awa awa awawa ]

[ awa awa awa awa awa awa awa awa
  awa awa awa awa awa awa awawa
  awa awa awa awa awa awa awa awa ]
\end{verbatim}

\appendix
\chapter{Reference Material}
\section{Introduction}
This appendix contains quick reference material: lists and tables with
essential information about certain topics.

Except for important notes in specific cases, there will not be any
detailed explanation; it is recommended to first read the preceding
chapters in case something is not clear.

\section{List of commands}
\label{list-of-opcodes}
\begin{longtable}{lll}
  \toprule
  Command & Awatism & Parameter \\
  \midrule \endhead

  \bottomrule \endfoot

  \textbf{NOP} & \verb|awa awa awa awa awa| & None \\
  \textbf{PRN} & \verb|awa awa awa awawa| & None \\
  \textbf{PR1} & \verb|awa awa awawa awa| & None \\
  \textbf{RED} & \verb|awa awa awawawa| & None \\
  \textbf{R3D} & \verb|awa awawa awa awa| & None \\
  \textbf{BLO} & \verb|awa awawa awawa| & Number \\
  \textbf{SBM} & \verb|awa awawawa awa| & Number \\
  \textbf{POP} & \verb|awa awawawawa| & None \\
  \textbf{DPL} & \verb|awawa awa awa awa| & None \\
  \textbf{SRN} & \verb|awawa awa awawa| & Number \\
  \textbf{MRG} & \verb|awawa awawa awa| & None \\
  \textbf{4DD} & \verb|awawa awawawa| & None \\
  \textbf{SUB} & \verb|awawawa awa awa| & None \\
  \textbf{MUL} & \verb|awawawa awawa| & None \\
  \textbf{DIV} & \verb|awawawawa awa| & None \\
  \textbf{CNT} & \verb|awawawawawa| & None \\
  \textbf{LBL} & \verb|~wa awa awa awa awa| & Number \\
  \textbf{JMP} & \verb|~wa awa awa awawa| & Numeric label \\
  \textbf{EQL} & \verb|~wa awa awawa awa| & None \\
  \textbf{LSS} & \verb|~wa awa awawawa| & None \\
  \textbf{GR8} & \verb|~wa awawa awa awa| & None \\
  \textbf{EQZ} & \verb|~wa awawa awawa| & None \\
  \textbf{TLB} & \verb|~wa awawawa awa| & AWASCII \\
  \textbf{JTL} & \verb|~wa awawawawa| & AWASCII label \\
  \textbf{CLL} & \verb|~wawa awa awa awa| & AWASCII label \\
  \textbf{RET} & \verb|~wawa awa awawa| & None \\
  \textbf{TRM} & \verb|~wawawawawa| & None \\
\end{longtable}

\begin{description}
\item[NOP] Does nothing and produces no effects.
\item[PRN] Print the top bubble as AWASCII and remove it from the abyss.
\item[PR1] Print the top bubble as a number and remove it from the abyss.
\item[RED] Request a line of AWASCII text from the user. The line will
  be stored as a double bubble comprising each character as a simple
  bubble.
\item[R3D] Request a number from the user and push it as a single
  bubble inside the abyss.
\item[BLO] Push the parameter inside the abyss.
\item[SMB] Push the top bubble down by a number of positions indicated
  by the parameter. A parameter of zero will push the bubble to the
  very bottom of the abyss.
\item[POP] Pop the top bubble off the abyss. If the bubble is double,
  each contained bubble will be pushed inside the abyss in the same
  order.
\item[DPL] Duplicate the top bubble and push it inside the
  abyss. Double bubbles will have their contents duplicated too.
\item[SRN] Create a double bubble containing the number of bubbles
  indicated by the parameter. These bubbles are moved inside the
  double bubble and not duplicated.
\item[MRG] Merge the first two bubbles into a double bubble. When at
  least one bubble is double, the contents are merged into a single
  double bubble.
\item[4DD] Sum the contents of the first two bubbles, pop them off the
  abyss and push a new bubble with the result inside the abyss. If one
  is a double bubble and the other a simple bubble, sum the value of
  the simple bubble to each item inside the double bubble; if both are
  double bubbles, sum each item until the smallest bubble runs out.
\item[SUB] Subtract the contents of the first two bubbles, pop them
  off the abyss and push a new bubble with the result inside the
  abyss. If one is a double bubble and the other a simple bubble,
  subtract the value of the simple bubble to each item inside the
  double bubble; if both are double bubbles, subtract each item until
  the smallest bubble runs out. The second bubble is subtracted from
  the top bubble.
\item[MUL] Multiply the contents of the first two bubbles, pop them
  off the abyss and push a new bubble with the result inside the
  abyss. If one is a double bubble and the other a simple bubble,
  multiply the value of the simple bubble to each item inside the
  double bubble; if both are double bubbles, multiply each item until
  the smallest bubble runs out.
\item[DIV] Divide the contents of the first two bubbles, pop them off
  the abyss and push a new bubble with the result inside the abyss. If
  one is a double bubble and the other a simple bubble, divide the
  value of the simple bubble to each item inside the double bubble; if
  both are double bubbles, divide each item until the smallest bubble
  runs out. The result is a double bubble whose first bubble is the
  quotient and the second bubble is the remainder.
\item[CNT] Push a new bubble inside the abyss with the size, in number
  of items, of the top bubble. A simple bubble has a size of zero.
\item[LBL] Register the current address at the given parameter.
\item[JMP] Move the internal instruction pointer to the address
  registered under the given parameter. Command execution will then
  resume at said address.
\item[EQL] Compare the first two bubbles: if the they have equal
  contents the next command is executed, otherwise it will be
  skipped. Single bubbles are compared directly, double bubbles will
  have each item compared.
\item[LSS] Compare the first two bubbles: if the top bubble is less
  than the bubble below the next command is executed, otherwise it
  will be skipped. Single bubbles are compared directly, double
  bubbles will have each item compared.
\item[GR8] Compare the first two bubbles: if the top bubble is greater
  than the bubble below the next command is executed, otherwise it
  will be skipped. Single bubbles are compared directly, double
  bubbles will have each item compared.
\item[EQZ] Skip the next command if the top bubble is either a double
  bubble or its value is not zero.
\item[TLB] Register the current address at the given parameter.
\item[JTL] Move the internal instruction pointer to the address
  registered under the given parameter. Command execution will then
  resume at said address.
\item[CLL] Save the current address and move the internal instruction
  pointer to the address registered under the given parameter. Command
  execution will then resume at said address. Each saved address will
  exist until the program resumes execution from one of them with the
  appropriate command.
\item[RET] Move the internal instruction pointer to the last saved
  address. Command execution will then resume at said address. The
  saved address is forgotten after execution is resumed.
\item[TRM] Terminate program execution, irrespective of any command
  that follows.
\end{description}

\section{AWASCII table}
\label{list-of-awascii}
\begin{tabular}{@{}ccclccclccc@{}}
  \toprule
  Dec. & Hex. & Value && Dec. & Hex. & Value && Dec. & Hex. & Value \\
  \midrule
  0 & 00 & A && 22 & 16 & u && 44 & 2C & 2 \\
  1 & 01 & W && 23 & 17 & m && 45 & 2D & 3 \\
  2 & 02 & a && 24 & 18 & P && 46 & 2E & 4 \\
  3 & 03 & w && 25 & 19 & C && 47 & 2F & 5 \\
  4 & 04 & J && 26 & 1A & N && 48 & 30 & 6 \\
  5 & 05 & E && 27 & 1B & T && 49 & 31 & 7 \\
  6 & 06 & L && 28 & 1C & p && 50 & 32 & 8 \\
  7 & 07 & Y && 29 & 1D & c && 51 & 33 & 9 \\
  8 & 08 & H && 30 & 1E & n && 52 & 34 & Blank\textsuperscript{\dag} \\
  9 & 09 & O && 31 & 1F & t && 53 & 35 & \verb|.| \\
  10 & 0A & S && 32 & 20 & B && 54 & 36 & \verb|,| \\
  11 & 0B & I && 33 & 21 & D && 55 & 37 & \verb|!| \\
  12 & 0C & U && 34 & 22 & F && 56 & 38 & \verb|'| \\
  13 & 0D & M && 35 & 23 & G && 57 & 39 & \verb|(| \\
  14 & 0E & j && 36 & 24 & R && 58 & 3A & \verb|)| \\
  15 & 0F & e && 37 & 25 & b && 59 & 3B & \verb|~| \\
  16 & 10 & l && 38 & 26 & d && 60 & 3C & \verb|_| \\
  17 & 11 & y && 39 & 27 & f && 61 & 3D & \verb|/| \\
  18 & 12 & h && 40 & 28 & g && 62 & 3E & \verb|;| \\
  19 & 13 & o && 41 & 29 & r && 63 & 3F & End of line\textsuperscript{\dag} \\
  20 & 14 & s && 42 & 2A & 0 &&&& \\
  21 & 15 & i && 43 & 2B & 1 &&&& \\
  \bottomrule
\end{tabular}

\textsuperscript{\dag}\enquote{Blank} indicates a visible space; \enquote{End of line} will
terminate the current line and will move the cursor to the beginning
of the next. The end of a line is represented by a sequence of
characters which can change according to the underlying system.
\end{document}
